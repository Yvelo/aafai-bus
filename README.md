<div align="center">
  <img src="static/Logo AAF.png" alt="AAF Logo" width="150"/>
</div>

# aafai-bus: An On-Demand Asynchronous Task Processor

> **Note:** This entire project, including the Python/Flask server, the Google Apps Script client, all documentation, and the complete test suite, was generated by **Google's Gemini Code Assistant** in PyCharm in under four hours, with no lines of code or documentation produced by a human.

## 1. Purpose

**aafai-bus** is a lightweight, on-demand Python server designed to handle long-running, resource-intensive tasks that are delegated from other services. Its primary use case is to act as a "boot-on-demand mini bus" for batch-processing occasional deep internet searches, such as those requiring a full browser via Selenium.

The core goal is to **minimize cloud costs** by keeping the server turned off by default. It is started on-demand by a client, processes a queue of tasks, and then automatically shuts itself down after a period of inactivity.

## 2. Architecture

The system is designed around a client-server model where the client is expected to have the ability to start the server's Virtual Machine (e.g., via a cloud provider's API).

**Typical Flow:**

1.  **Client (e.g., Google Apps Script in a GSheet):** A user triggers an action in a Google Sheet.
2.  **Start VM:** The Apps Script calls the Google Cloud API to start the `aafai-bus` VM instance.
3.  **Submit Task:** Once the VM is running, the script sends a task to the server's `/inbound` endpoint. The server writes the task to a file-based queue and immediately returns a `job_id`.
4.  **Process Task:** The server's background scheduler picks up the task from the queue, executes the requested action, and writes the result to an outbound file.
5.  **Poll for Result:** The Apps Script sets up a time-based trigger to periodically call the server's `/outbound` endpoint with the `job_id`.
6.  **Retrieve Result:** Once the task is complete, the `/outbound` endpoint returns the final JSON result.
7.  **Auto-Shutdown:** After a configurable period of inactivity, the server initiates a graceful shutdown.

## 3. Security Architecture

To ensure that the `aafai-bus` server only accepts requests from trusted sources, it is critical to configure a firewall rule at the VPC level. This is the most secure way to protect the server, as it blocks unauthorized traffic before it even reaches the application.

When the client is a Google Apps Script, we can restrict access to the specific IP ranges that Google uses for `UrlFetchApp` requests.

### Google Cloud Platform (GCP) Firewall Setup

1.  **Find Google's IP Ranges:** Run the following command to get the current IP ranges for Apps Script:
    ```sh
    nslookup -q=TXT _appsscript.google.com
    ```
2.  **Create a Firewall Rule:** In your GCP project, navigate to **VPC network > Firewall** and create a new **ingress** rule with the following settings:
    - **Name:** `allow-google-apps-script`
    - **Targets:** Apply the rule to your VM using a specific **target tag** (e.g., `aafai-bus-server`).
    - **Source IPv4 ranges:** Enter the IP blocks from step 1.
    - **Protocols and ports:** `tcp:8000` (or your Gunicorn port).
3.  **Tag Your VM:** Add the network tag (e.g., `aafai-bus-server`) to your VM instance in **Compute Engine**.

## 4. Testing Strategy

The project includes a comprehensive test suite using `pytest`. The tests are organized to ensure reliability and maintainability.

To run the tests, execute the following command from the project root:
```sh
pytest
```

### Unit Tests (`tests/unit/`)
Unit tests are focused on testing individual functions and components in isolation. They use **mocks** to simulate the behavior of external dependencies (like network calls or file system access). This makes them extremely fast and reliable.

- `test_actions.py`: Tests the logic of individual actions.
- `test_scheduler.py`: Tests the scheduler's ability to handle bad input (e.g., malformed JSON, unknown actions).
- `test_inbound_api.py` / `test_outbound_api.py`: Test the API endpoints' logic without making real HTTP requests.

### Functional & Integration Tests
These tests verify that different parts of the system work together correctly.

- `tests/functional/test_full_workflow.py`: A functional test that ensures the inbound API correctly writes a task file to the queue.
- `tests/unit/test_download_website.py`: This contains a powerful **integration test** that starts a real, live HTTP server in the background and then runs the Selenium action against it. This provides high confidence that the browser automation works as expected without relying on a brittle external website.

## 5. Features

- **Dynamic Action System:** Add new capabilities by simply dropping a Python file into the `actions/` directory.
- **File-Based Queue:** A simple, durable, and transparent queueing system.
- **Asynchronous Processing:** Uses `APScheduler` with a thread pool to handle multiple tasks concurrently.
- **On-Demand & Auto-Shutdown:** Designed to be started by a client and automatically shuts down when idle.
- **Gunicorn & Systemd:** Ready for production deployment using industry-standard tools.

## 6. Setup & Deployment

### Python Environment
1.  Clone the repository.
2.  Create and activate a virtual environment: `python -m venv .venv` & `source .venv/bin/activate`.
3.  Install dependencies: `pip install -r requirements.txt`.
4.  Install a Selenium WebDriver (e.g., `chromedriver`) and ensure it is in your system's PATH.

### Production Deployment (Linux)
1.  Copy the `aafai-bus.service` file to `/etc/systemd/system/`.
2.  Update paths in the service file to match your deployment directory.
3.  Reload the systemd daemon: `sudo systemctl daemon-reload`.
4.  Enable and start the service: `sudo systemctl enable --now aafai-bus.service`.

## 7. Configuration

Configuration is managed via environment variables, set in the `aafai-bus.service` file for production.

- `APP_ENV`: `production` or `development`.
- `QUEUE_BASE_PATH`: Absolute path for storing queues (e.g., `/var/www/aafai-bus/prod_queues`).

## 8. API Endpoints

### `POST /inbound`
Submits a new task.
- **Body:** `{ "action": "action_name", "params": { ... } }`
- **Response:** `{ "status": "received", "job_id": "..." }`

### `GET /outbound`
Polls for a task result.
- **URL:** `/outbound?job_id=...`
- **Pending Response:** `{ "status": "pending", ... }`
- **Complete Response:** `{ "status": "complete", "result": { ... } }`

## 9. Google Apps Script Integration

An example client implementation using Google Apps Script can be found here: [examples/google_apps_script/master-bus.gs](examples/google_apps_script/master-bus.gs).

This script can be added to a Google Sheet to:
- Provide a custom menu to start tasks.
- Automatically start the `aafai-bus` VM on Google Cloud.
- Submit tasks and poll for results.
- Display completion/failure notifications to the user.
